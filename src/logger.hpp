// MIT License
//
// Copyright (c) 2025 SlickTech
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



// ********** THIS FILE IS AUTO-GENERATED FROM src/logger.hpp **********
// ********** DO NOT EDIT THIS FILE DIRECTLY                  **********
// ********** EDIT src/logger.hpp AND RE-RUN CMAKE TO UPDATE  **********

#pragma once

#include <string>
#include <cstdint>
#include <thread>
#include <atomic>
#include <filesystem>
#include <memory>
#include <functional>
#include <iostream>
#include <fstream>
#include <chrono>
#include <iomanip>
#include <ctime>
#include <format>
#include <utility>
#include <vector>
#include <slick_queue.h>

#define SLICK_LOGGER_VERSION_MAJOR @slick_logger_VERSION_MAJOR@
#define SLICK_LOGGER_VERSION_MINOR @slick_logger_VERSION_MINOR@
#define SLICK_LOGGER_VERSION_PATCH @slick_logger_VERSION_PATCH@
#define SLICK_LOGGER_VERSION_TWEAK @slick_logger_VERSION_TWEAK@
#define SLICK_LOGGER_VERSION "@slick_logger_VERSION_MAJOR@.@slick_logger_VERSION_MINOR@.@slick_logger_VERSION_PATCH@.@slick_logger_VERSION_TWEAK@"

namespace slick_logger {

enum class LogLevel : uint8_t {
    L_TRACE = 0,
    L_DEBUG = 1,
    L_INFO = 2,
    L_WARN = 3,
    L_ERROR = 4,
    L_FATAL = 5,
    L_OFF = 6,
};

inline constexpr const char* to_string(LogLevel level) noexcept {
    switch (level) {
        case LogLevel::L_TRACE: return "TRACE";
        case LogLevel::L_DEBUG: return "DEBUG";
        case LogLevel::L_INFO:  return "INFO";
        case LogLevel::L_WARN:  return "WARN";
        case LogLevel::L_ERROR: return "ERROR";
        case LogLevel::L_FATAL: return "FATAL";
        case LogLevel::L_OFF:   return "OFF";
        default:              return "UNKNOWN";
    }
}

class TimestampFormatter {
public:
    enum class Format {
        DEFAULT,          // 2024-08-26 15:30:45
        WITH_MICROSECONDS, // 2024-08-26 15:30:45.123456
        WITH_MILLISECONDS, // 2024-08-26 15:30:45.123
        ISO8601,          // 2024-08-26T15:30:45.123456Z
        TIME_ONLY,        // 15:30:45.123456
        CUSTOM            // User-defined format
    };

    TimestampFormatter(Format fmt = Format::WITH_MICROSECONDS) : format_(fmt) {}
    
    TimestampFormatter(const std::string& custom_format) 
        : format_(Format::CUSTOM), custom_format_(custom_format) {}

    std::string format_timestamp(uint64_t timestamp_ns) const {
        auto duration = std::chrono::nanoseconds(timestamp_ns);
        auto time_point = std::chrono::system_clock::time_point(
            std::chrono::duration_cast<std::chrono::system_clock::duration>(duration));
        
        time_t time_val = std::chrono::system_clock::to_time_t(time_point);
        std::tm tm = *std::localtime(&time_val);
        
        // Extract microseconds and milliseconds
        auto microseconds = std::chrono::duration_cast<std::chrono::microseconds>(duration).count() % 1000000;
        auto milliseconds = microseconds / 1000;
        
        std::ostringstream oss;
        
        switch (format_) {
            case Format::DEFAULT:
                oss << std::put_time(&tm, "%Y-%m-%d %H:%M:%S");
                break;
                
            case Format::WITH_MICROSECONDS:
                oss << std::put_time(&tm, "%Y-%m-%d %H:%M:%S")
                    << "." << std::setfill('0') << std::setw(6) << microseconds;
                break;
                
            case Format::WITH_MILLISECONDS:
                oss << std::put_time(&tm, "%Y-%m-%d %H:%M:%S")
                    << "." << std::setfill('0') << std::setw(3) << milliseconds;
                break;
                
            case Format::ISO8601:
                oss << std::put_time(&tm, "%Y-%m-%dT%H:%M:%S")
                    << "." << std::setfill('0') << std::setw(6) << microseconds << "Z";
                break;
                
            case Format::TIME_ONLY:
                oss << std::put_time(&tm, "%H:%M:%S")
                    << "." << std::setfill('0') << std::setw(6) << microseconds;
                break;
                
            case Format::CUSTOM:
                if (!custom_format_.empty()) {
                    // Handle %f placeholder for microseconds in custom format
                    std::string format = custom_format_;
                    size_t pos = format.find("%f");
                    if (pos != std::string::npos) {
                        format.replace(pos, 2, std::to_string(microseconds));
                    }
                    oss << std::put_time(&tm, format.c_str());
                    return oss.str();
                } else {
                    oss << std::put_time(&tm, "%Y-%m-%d %H:%M:%S");
                }
                break;
        }
        
        return oss.str();
    }

private:
    Format format_;
    std::string custom_format_;
};

struct LogEntry {
    LogLevel level;
    std::function<std::string()> formatter; // Lambda that returns formatted message
    uint64_t timestamp; // nanoseconds since epoch
};

class ISink {
public:
    virtual ~ISink() = default;
    virtual void write(const LogEntry& entry) = 0;
    virtual void flush() = 0;
};

struct RotationConfig {
    size_t max_file_size = 10 * 1024 * 1024; // 10MB
    size_t max_files = 5;
    bool compress_old = false;
    std::chrono::hours rotation_hour = std::chrono::hours(0); // Daily at midnight
};

class ConsoleSink : public ISink {
public:
    explicit ConsoleSink(bool use_colors = true, bool use_stderr_for_errors = true, 
                        TimestampFormatter::Format timestamp_format = TimestampFormatter::Format::WITH_MICROSECONDS);
    
    explicit ConsoleSink(const std::string& custom_timestamp_format, bool use_colors = true, 
                        bool use_stderr_for_errors = true);
    
    void write(const LogEntry& entry) override;
    void flush() override;

private:
    std::string format_log_entry(const LogEntry& entry);
    std::string get_color_code(LogLevel level);
    std::string get_reset_code();
    
    bool use_colors_;
    bool use_stderr_for_errors_;
    TimestampFormatter timestamp_formatter_;
};

class FileSink : public ISink {
public:
    explicit FileSink(const std::filesystem::path& file_path, 
                     TimestampFormatter::Format timestamp_format = TimestampFormatter::Format::WITH_MICROSECONDS);
    
    explicit FileSink(const std::filesystem::path& file_path, const std::string& custom_timestamp_format);
    
    void write(const LogEntry& entry) override;
    void flush() override;

protected:
    std::string format_log_entry(const LogEntry& entry);
    
    std::filesystem::path file_path_;
    std::ofstream file_stream_;
    TimestampFormatter timestamp_formatter_;
};

class RotatingFileSink : public FileSink {
public:
    RotatingFileSink(const std::filesystem::path& base_path, const RotationConfig& config,
                    TimestampFormatter::Format timestamp_format = TimestampFormatter::Format::WITH_MICROSECONDS);
    
    RotatingFileSink(const std::filesystem::path& base_path, const RotationConfig& config,
                    const std::string& custom_timestamp_format);
    
    void write(const LogEntry& entry) override;

private:
    void check_rotation();
    void rotate_files();
    std::filesystem::path get_rotated_filename(size_t index);
    
    RotationConfig config_;
    std::filesystem::path base_path_;
    size_t current_file_size_;
};

class DailyFileSink : public FileSink {
public:
    DailyFileSink(const std::filesystem::path& base_path, const RotationConfig& config,
                 TimestampFormatter::Format timestamp_format = TimestampFormatter::Format::WITH_MICROSECONDS);
    
    DailyFileSink(const std::filesystem::path& base_path, const RotationConfig& config,
                 const std::string& custom_timestamp_format);
    
    void write(const LogEntry& entry) override;

protected:
    void check_rotation();
    virtual std::string get_date_string();

    std::filesystem::path get_daily_filename();
    std::filesystem::path get_dated_filename(const std::string& date);
    
    RotationConfig config_;
    std::filesystem::path base_path_;
    std::string current_date_;
};

struct LogConfig {
    std::vector<std::shared_ptr<ISink>> sinks;
    LogLevel min_level = LogLevel::L_TRACE;
    size_t queue_size = 65536;
};

class Logger {
public:
    static Logger& instance();

    void init(const std::filesystem::path& log_file, size_t queue_size = 65536);
    void init(const LogConfig& config);
    void init(size_t queue_size = 65536);
    
    void add_sink(std::shared_ptr<ISink> sink);
    void clear_sinks();
    
    void add_console_sink(bool use_colors = true, bool use_stderr_for_errors = true);
    void add_console_sink(TimestampFormatter::Format timestamp_format, bool use_colors = true, bool use_stderr_for_errors = true);
    void add_console_sink(const std::string& custom_timestamp_format, bool use_colors = true, bool use_stderr_for_errors = true);
    
    void add_file_sink(const std::filesystem::path& path, const RotationConfig& config = {});
    void add_file_sink(const std::filesystem::path& path, TimestampFormatter::Format timestamp_format, const RotationConfig& config = {});
    void add_file_sink(const std::filesystem::path& path, const std::string& custom_timestamp_format, const RotationConfig& config = {});
    
    void add_rotating_file_sink(const std::filesystem::path& path, const RotationConfig& config);
    void add_rotating_file_sink(const std::filesystem::path& path, const RotationConfig& config, TimestampFormatter::Format timestamp_format);
    void add_rotating_file_sink(const std::filesystem::path& path, const RotationConfig& config, const std::string& custom_timestamp_format);
    
    void add_daily_file_sink(const std::filesystem::path& path, const RotationConfig& config = {});
    void add_daily_file_sink(const std::filesystem::path& path, const RotationConfig& config, TimestampFormatter::Format timestamp_format);
    void add_daily_file_sink(const std::filesystem::path& path, const RotationConfig& config, const std::string& custom_timestamp_format);

    void set_log_level(LogLevel level) {
        log_level_.store(level, std::memory_order_release);
    }

    template<typename... Args>
    void log(LogLevel level, const std::string& format, Args&&... args);

    void shutdown();
    void reset(); // For testing - clears everything and allows reinitialization

private:
    Logger() = default;
    ~Logger();

    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;

    void writer_thread_func();
    void write_log_entry(const LogEntry* entry_ptr, uint32_t count);

    slick::SlickQueue<LogEntry>* queue_;
    std::vector<std::shared_ptr<ISink>> sinks_;
    std::filesystem::path log_file_;
    std::thread writer_thread_;
    std::atomic<bool> running_{false};
    uint64_t read_index_{0};
    std::atomic<LogLevel> log_level_{LogLevel::L_TRACE};
};

// Implementation (header-only library)

inline ConsoleSink::ConsoleSink(bool use_colors, bool use_stderr_for_errors, 
                                TimestampFormatter::Format timestamp_format)
    : use_colors_(use_colors), use_stderr_for_errors_(use_stderr_for_errors), 
      timestamp_formatter_(timestamp_format) {
}

inline ConsoleSink::ConsoleSink(const std::string& custom_timestamp_format, bool use_colors, 
                                bool use_stderr_for_errors)
    : use_colors_(use_colors), use_stderr_for_errors_(use_stderr_for_errors), 
      timestamp_formatter_(custom_timestamp_format) {
}

inline void ConsoleSink::write(const LogEntry& entry) {
    std::string formatted = format_log_entry(entry);
    
    if (use_stderr_for_errors_ && (entry.level >= LogLevel::L_WARN)) {
        std::cerr << formatted << std::endl;
    } else {
        std::cout << formatted << std::endl;
    }
}

inline void ConsoleSink::flush() {
    std::cout.flush();
    std::cerr.flush();
}

inline std::string ConsoleSink::format_log_entry(const LogEntry& entry) {
    std::string level_str = to_string(entry.level);
    std::string timestamp = timestamp_formatter_.format_timestamp(entry.timestamp);
    std::string message = entry.formatter();
    std::string result = timestamp + " [" + level_str + "] " + message;
    
    if (use_colors_) {
        return get_color_code(entry.level) + result + get_reset_code();
    }
    
    return result;
}

inline std::string ConsoleSink::get_color_code(LogLevel level) {
    switch (level) {
        case LogLevel::L_TRACE: return "\033[90m";   // Dark gray
        case LogLevel::L_DEBUG: return "\033[36m";   // Cyan
        case LogLevel::L_INFO: return "\033[32m";    // Green
        case LogLevel::L_WARN: return "\033[33m";    // Yellow
        case LogLevel::L_ERROR: return "\033[31m";     // Red
        case LogLevel::L_FATAL: return "\033[91m";   // Bright red
        default: return "";
    }
}

inline std::string ConsoleSink::get_reset_code() {
    return "\033[0m";
}

inline FileSink::FileSink(const std::filesystem::path& file_path, 
                          TimestampFormatter::Format timestamp_format)
    : file_path_(file_path), timestamp_formatter_(timestamp_format) {
    file_stream_.open(file_path_, std::ios::app);
    if (!file_stream_) {
        throw std::runtime_error("Failed to open log file: " + file_path_.string());
    }
}

inline FileSink::FileSink(const std::filesystem::path& file_path, const std::string& custom_timestamp_format)
    : file_path_(file_path), timestamp_formatter_(custom_timestamp_format) {
    file_stream_.open(file_path_, std::ios::app);
    if (!file_stream_) {
        throw std::runtime_error("Failed to open log file: " + file_path_.string());
    }
}

inline void FileSink::write(const LogEntry& entry) {
    if (file_stream_) {
        file_stream_ << format_log_entry(entry) << std::endl;
    }
}

inline void FileSink::flush() {
    if (file_stream_) {
        file_stream_.flush();
    }
}

inline std::string FileSink::format_log_entry(const LogEntry& entry) {
    std::string level_str = to_string(entry.level);
    std::string timestamp = timestamp_formatter_.format_timestamp(entry.timestamp);
    std::string message = entry.formatter();
    return timestamp + " [" + level_str + "] " + message;
}

inline RotatingFileSink::RotatingFileSink(const std::filesystem::path& base_path, const RotationConfig& config,
                                        TimestampFormatter::Format timestamp_format)
    : FileSink(base_path, timestamp_format), config_(config), base_path_(base_path), current_file_size_(0) {
    if (std::filesystem::exists(base_path_)) {
        current_file_size_ = std::filesystem::file_size(base_path_);
    }
}

inline RotatingFileSink::RotatingFileSink(const std::filesystem::path& base_path, const RotationConfig& config,
                                        const std::string& custom_timestamp_format)
    : FileSink(base_path, custom_timestamp_format), config_(config), base_path_(base_path), current_file_size_(0) {
    if (std::filesystem::exists(base_path_)) {
        current_file_size_ = std::filesystem::file_size(base_path_);
    }
}

inline void RotatingFileSink::write(const LogEntry& entry) {
    check_rotation();
    
    std::string formatted = format_log_entry(entry);
    if (file_stream_) {
        file_stream_ << formatted << std::endl;
        current_file_size_ += formatted.length() + 1; // +1 for newline
    }
}

inline void RotatingFileSink::check_rotation() {
    if (current_file_size_ >= config_.max_file_size) {
        rotate_files();
    }
}

inline void RotatingFileSink::rotate_files() {
    file_stream_.close();
    
    // Remove the oldest file if it exists
    auto oldest_file = get_rotated_filename(config_.max_files - 1);
    if (std::filesystem::exists(oldest_file)) {
        std::filesystem::remove(oldest_file);
    }
    
    // Rotate existing files
    for (size_t i = config_.max_files - 1; i > 0; --i) {
        auto src = (i == 1) ? base_path_ : get_rotated_filename(i - 1);
        auto dst = get_rotated_filename(i);
        
        if (std::filesystem::exists(src)) {
            std::filesystem::rename(src, dst);
        }
    }
    
    // Create new current file
    file_stream_.open(base_path_, std::ios::out | std::ios::trunc);
    current_file_size_ = 0;
}

inline std::filesystem::path RotatingFileSink::get_rotated_filename(size_t index) {
    std::string filename = base_path_.stem().string() + "_" + std::to_string(index) + base_path_.extension().string();
    return base_path_.parent_path() / filename;
}

inline DailyFileSink::DailyFileSink(const std::filesystem::path& base_path, const RotationConfig& config,
                                  TimestampFormatter::Format timestamp_format)
    : FileSink(base_path, timestamp_format), config_(config), base_path_(base_path) {
    current_date_ = get_date_string();
    // Keep logging to base_path (e.g., daily.log) - FileSink constructor already opened it
}

inline DailyFileSink::DailyFileSink(const std::filesystem::path& base_path, const RotationConfig& config,
                                  const std::string& custom_timestamp_format)
    : FileSink(base_path, custom_timestamp_format), config_(config), base_path_(base_path) {
    current_date_ = get_date_string();
    // Keep logging to base_path (e.g., daily.log) - FileSink constructor already opened it
}

inline void DailyFileSink::write(const LogEntry& entry) {
    check_rotation();
    FileSink::write(entry);
}

inline void DailyFileSink::check_rotation() {
    std::string today = get_date_string();
    if (today != current_date_) {
        // Close current file
        file_stream_.close();
        
        // Rename current base file to dated filename (e.g., daily.log -> daily_2025-08-24.log)
        std::filesystem::path old_dated_file = get_dated_filename(current_date_);
        std::error_code ec;
        if (std::filesystem::exists(base_path_)) {
            std::filesystem::rename(base_path_, old_dated_file, ec);
            if (ec) {
                // If rename fails, try copy and remove
                std::filesystem::copy_file(base_path_, old_dated_file, ec);
                if (!ec) {
                    std::filesystem::remove(base_path_, ec);
                }
            }
        }
        
        // Reopen base file for new day's logs
        file_stream_.open(base_path_, std::ios::out | std::ios::trunc); // Start fresh for new day
        if (!file_stream_) {
            throw std::runtime_error("Failed to reopen daily log file: " + base_path_.string());
        }
        
        current_date_ = today;
    }
}

inline std::filesystem::path DailyFileSink::get_daily_filename() {
    std::string date_str = get_date_string();
    return get_dated_filename(date_str);
}

inline std::filesystem::path DailyFileSink::get_dated_filename(const std::string& date) {
    std::string filename = base_path_.stem().string() + "_" + date + base_path_.extension().string();
    return base_path_.parent_path() / filename;
}

inline std::string DailyFileSink::get_date_string() {
    auto now = std::chrono::system_clock::now();
    time_t time_val = std::chrono::system_clock::to_time_t(now);
    std::tm tm = *std::localtime(&time_val);
    
    char date_str[11];
    std::strftime(date_str, sizeof(date_str), "%Y-%m-%d", &tm);
    return std::string(date_str);
}

inline Logger& Logger::instance() {
    static Logger instance;
    return instance;
}

inline void Logger::init(const std::filesystem::path& log_file, size_t queue_size) {
    // Backwards compatibility - create file sink for the specified file
    clear_sinks();
    add_sink(std::make_shared<FileSink>(log_file));
    
    // Ensure queue_size is power of 2
    if (queue_size & (queue_size - 1)) {
        // Round up to next power of 2
        size_t temp = queue_size;
        temp--;
        temp |= temp >> 1;
        temp |= temp >> 2;
        temp |= temp >> 4;
        temp |= temp >> 8;
        temp |= temp >> 16;
        temp |= temp >> 32;
        queue_size = temp + 1;
    }

    queue_ = new slick::SlickQueue<LogEntry>(static_cast<uint32_t>(queue_size));
    log_file_ = log_file;
    running_ = true;
    
    // Initialize read_index_ before starting the thread
    read_index_ = queue_->initial_reading_index();
    
    writer_thread_ = std::thread([this]() { writer_thread_func(); });
    
    // Give a small delay to ensure writer thread is started
    std::this_thread::sleep_for(std::chrono::milliseconds(1));
}

inline void Logger::init(const LogConfig& config) {
    clear_sinks();
    
    for (auto& sink : config.sinks) {
        add_sink(sink);
    }
    
    set_log_level(config.min_level);
    
    // Ensure queue_size is power of 2
    size_t queue_size = config.queue_size;
    if (queue_size & (queue_size - 1)) {
        // Round up to next power of 2
        size_t temp = queue_size;
        temp--;
        temp |= temp >> 1;
        temp |= temp >> 2;
        temp |= temp >> 4;
        temp |= temp >> 8;
        temp |= temp >> 16;
        temp |= temp >> 32;
        queue_size = temp + 1;
    }

    queue_ = new slick::SlickQueue<LogEntry>(static_cast<uint32_t>(queue_size));
    running_ = true;
    
    // Initialize read_index_ before starting the thread
    read_index_ = queue_->initial_reading_index();
    
    writer_thread_ = std::thread([this]() { writer_thread_func(); });
    
    // Give a small delay to ensure writer thread is started
    std::this_thread::sleep_for(std::chrono::milliseconds(1));
}

inline void Logger::add_sink(std::shared_ptr<ISink> sink) {
    sinks_.push_back(sink);
}

inline void Logger::clear_sinks() {
    sinks_.clear();
}

inline void Logger::init(size_t queue_size) {
    // Initialize logger with empty sinks - sinks should be added before calling this
    // Ensure queue_size is power of 2
    if (queue_size & (queue_size - 1)) {
        // Round up to next power of 2
        size_t temp = queue_size;
        temp--;
        temp |= temp >> 1;
        temp |= temp >> 2;
        temp |= temp >> 4;
        temp |= temp >> 8;
        temp |= temp >> 16;
        temp |= temp >> 32;
        queue_size = temp + 1;
    }

    queue_ = new slick::SlickQueue<LogEntry>(static_cast<uint32_t>(queue_size));
    running_ = true;
    
    // Initialize read_index_ before starting the thread
    read_index_ = queue_->initial_reading_index();
    
    writer_thread_ = std::thread([this]() { writer_thread_func(); });
    
    // Give a small delay to ensure writer thread is started
    std::this_thread::sleep_for(std::chrono::milliseconds(1));
}

inline void Logger::add_console_sink(bool use_colors, bool use_stderr_for_errors) {
    add_sink(std::make_shared<ConsoleSink>(use_colors, use_stderr_for_errors));
}

inline void Logger::add_console_sink(TimestampFormatter::Format timestamp_format, bool use_colors, bool use_stderr_for_errors) {
    add_sink(std::make_shared<ConsoleSink>(use_colors, use_stderr_for_errors, timestamp_format));
}

inline void Logger::add_console_sink(const std::string& custom_timestamp_format, bool use_colors, bool use_stderr_for_errors) {
    add_sink(std::make_shared<ConsoleSink>(custom_timestamp_format, use_colors, use_stderr_for_errors));
}

inline void Logger::add_file_sink(const std::filesystem::path& path, const RotationConfig& config) {
    add_sink(std::make_shared<FileSink>(path));
}

inline void Logger::add_file_sink(const std::filesystem::path& path, TimestampFormatter::Format timestamp_format, const RotationConfig& config) {
    add_sink(std::make_shared<FileSink>(path, timestamp_format));
}

inline void Logger::add_file_sink(const std::filesystem::path& path, const std::string& custom_timestamp_format, const RotationConfig& config) {
    add_sink(std::make_shared<FileSink>(path, custom_timestamp_format));
}

inline void Logger::add_rotating_file_sink(const std::filesystem::path& path, const RotationConfig& config) {
    add_sink(std::make_shared<RotatingFileSink>(path, config));
}

inline void Logger::add_rotating_file_sink(const std::filesystem::path& path, const RotationConfig& config, TimestampFormatter::Format timestamp_format) {
    add_sink(std::make_shared<RotatingFileSink>(path, config, timestamp_format));
}

inline void Logger::add_rotating_file_sink(const std::filesystem::path& path, const RotationConfig& config, const std::string& custom_timestamp_format) {
    add_sink(std::make_shared<RotatingFileSink>(path, config, custom_timestamp_format));
}

inline void Logger::add_daily_file_sink(const std::filesystem::path& path, const RotationConfig& config) {
    add_sink(std::make_shared<DailyFileSink>(path, config));
}

inline void Logger::add_daily_file_sink(const std::filesystem::path& path, const RotationConfig& config, TimestampFormatter::Format timestamp_format) {
    add_sink(std::make_shared<DailyFileSink>(path, config, timestamp_format));
}

inline void Logger::add_daily_file_sink(const std::filesystem::path& path, const RotationConfig& config, const std::string& custom_timestamp_format) {
    add_sink(std::make_shared<DailyFileSink>(path, config, custom_timestamp_format));
}

template<typename... Args>
inline void Logger::log(LogLevel level, const std::string& format, Args&&... args) {
    if (!running_ || !queue_ || level < log_level_.load(std::memory_order_relaxed))
    {
        return;
    }

    auto now = std::chrono::system_clock::now();
    auto ns = std::chrono::duration_cast<std::chrono::nanoseconds>(now.time_since_epoch()).count();

    // Create lambda that captures format and arguments, formats when called
    auto formatter = [format, args_tuple = std::make_tuple(std::forward<Args>(args)...)]() mutable -> std::string {
        return std::apply([&format](auto&&... unpacked_args) -> std::string {
            return std::vformat(format, std::make_format_args(std::forward<decltype(unpacked_args)>(unpacked_args)...));
        }, args_tuple);
    };

    uint64_t index = queue_->reserve();
    auto &entry_ref = *(*queue_)[index];
    entry_ref.level = level;
    entry_ref.formatter = std::move(formatter);
    entry_ref.timestamp = static_cast<uint64_t>(ns);
    queue_->publish(index);
}

inline void Logger::shutdown() {
    if (!running_) return;
    running_ = false;
    if (writer_thread_.joinable()) {
        writer_thread_.join();
    }
    
    // Clear sinks to release file handles and other resources
    sinks_.clear();
    
    delete queue_;
    queue_ = nullptr;
}

inline Logger::~Logger() {
    shutdown();
}

inline void Logger::reset() {
    shutdown();
    // Reset all state for fresh initialization
    log_file_.clear();
    read_index_ = 0;
    log_level_.store(LogLevel::L_TRACE);
}

inline void Logger::writer_thread_func() {
    while (running_) {
        auto [entry_ptr, count] = queue_->read(read_index_);
        if (entry_ptr) {
            write_log_entry(entry_ptr, count);
        } else {
            std::this_thread::sleep_for(std::chrono::milliseconds(1)); // Small delay if no data
        }
    }
    
    // Drain remaining messages after running_ becomes false
    while (true) {
        auto [entry_ptr, count] = queue_->read(read_index_);
        if (!entry_ptr || count == 0) {
            break;
        }
        write_log_entry(entry_ptr, count);
    }
}

inline void Logger::write_log_entry(const LogEntry* entry_ptr, uint32_t count) {
    for (uint32_t i = 0; i < count; ++i) {
        const LogEntry& entry = entry_ptr[i];
        
        // Write to all configured sinks
        for (auto& sink : sinks_) {
            if (sink) {
                sink->write(entry);
            }
        }
    }
    
    // Flush all sinks
    for (auto& sink : sinks_) {
        if (sink) {
            sink->flush();
        }
    }
}

} // namespace slick_logger

// Macros for easy logging
#define LOG_TRACE(...) slick_logger::Logger::instance().log(slick_logger::LogLevel::L_TRACE, __VA_ARGS__)
#define LOG_DEBUG(...) slick_logger::Logger::instance().log(slick_logger::LogLevel::L_DEBUG, __VA_ARGS__)
#define LOG_INFO(...) slick_logger::Logger::instance().log(slick_logger::LogLevel::L_INFO, __VA_ARGS__)
#define LOG_WARN(...) slick_logger::Logger::instance().log(slick_logger::LogLevel::L_WARN, __VA_ARGS__)
#define LOG_ERROR(...) slick_logger::Logger::instance().log(slick_logger::LogLevel::L_ERROR, __VA_ARGS__)
#define LOG_FATAL(...) slick_logger::Logger::instance().log(slick_logger::LogLevel::L_FATAL, __VA_ARGS__)